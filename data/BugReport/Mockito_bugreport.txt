Mockito-1$$ArgumentCaptor no longer working for varargs$$When upgrading 1.10.8, the verify passes, but the getValue() fails with this error. One other piece of info came to light as a result of creating the MCVE - the test works fine if the Date is the only element passed for bindVariables. That is, remove "var1" from target and test code, then the test runs fine under 1.9.5 and 1.10.8. Also, it doesn't matter that the captor is for a Date. The same issue occurs if the parameter is of another type, such as Integer.
Mockito-2$$Mockito.after() method accepts negative timeperiods and subsequent verifications always pass$$None
Mockito-3$$ArgumentCaptor no longer working for varargs$$When upgrading 1.10.8, the verify passes, but the getValue() fails with this error. One other piece of info came to light as a result of creating the MCVE - the test works fine if the Date is the only element passed for bindVariables. That is, remove "var1" from target and test code, then the test runs fine under 1.9.5 and 1.10.8. Also, it doesn't matter that the captor is for a Date. The same issue occurs if the parameter is of another type, such as Integer.
Mockito-4$$java.lang.ClassCastException: java.lang.Class cannot be cast to java.lang.String$$Exception throws on verifyZeroInteractions when using mock with default answer.
Mockito-5$$Mockito 1.10.x timeout verification needs JUnit classes (VerifyError, NoClassDefFoundError)$$If JUnit is not on the classpath and mockito is version 1.10.x (as of now 1.10.1 up to 1.10.19) and the code is using the timeout verification which is not supposed to be related to JUnit, then the JVM may fail with a VerifyError or a NoClassDefFoundError.
Mockito-6$$Argument matcher anyXxx() (i.e. anyString(), anyList()) should not match nulls$$Note that the function is called with an integer (not a string), and still the mocked function return the value which it should return only when a string is passed. The same works when using anyBoolean() or any other methof from any* family.
Mockito-7$$Deep stubbing with generic responses in the call chain is not working$$Deep stubbing will throw an Exception if multiple generics occur in the call chain. For instance, consider having a mock myMock1 that provides a function that returns a generic T. If T also has a function that returns a generic, an Exception with the message "Raw extraction not supported for : 'null'" will be thrown. I think, the issue is that further generics are not possible to be mocked by ReturnsDeepStubsSerializationFallback since the GenericMetadataSupport is "closed" at this point.
Mockito-8$$1.10 regression (StackOverflowError) with interface where generic type has itself as upper bound.$$None
Mockito-9$$Problem spying on abstract classes$$There's a problem with spying on abstract classes when the real implementation calls out to the abstract method.
Mockito-10$$RETURNS_DEEP_STUBS automatically tries to create serializable mocks$$You are using the setting 'withSettings().serializable()' however the type you are trying to mock 'NotSerializableReturnValue' do not implement Serializable AND do not have a no-arg constructor.
Mockito-11$$Fixed DelegatingMethod.equals() so that it's easier to extend Mockito by custom verification modes$$Currently if you create a DelegatingMethod and compare it to itself using .equals() it will show as not equal because the .equals() method expects a java.lang.reflect.Method (without explicitly stating such). This has a knock on effect on the evaluation of InvocationImpl.equals() which at runtime may be using a DelegatingMethod in its .equals().
Mockito-12$$ArgumentCaptor no longer working for varargs$$When upgrading 1.10.8, the verify passes, but the getValue() fails with this error. One other piece of info came to light as a result of creating the MCVE - the test works fine if the Date is the only element passed for bindVariables. That is, remove "var1" from target and test code, then the test runs fine under 1.9.5 and 1.10.8. Also, it doesn't matter that the captor is for a Date. The same issue occurs if the parameter is of another type, such as Integer.
Mockito-13$$fix proposal for #114$$None
Mockito-14$$fix proposal for #114$$None
Mockito-15$$ArgumentCaptor no longer working for varargs$$When upgrading 1.10.8, the verify passes, but the getValue() fails with this error. One other piece of info came to light as a result of creating the MCVE - the test works fine if the Date is the only element passed for bindVariables. That is, remove "var1" from target and test code, then the test runs fine under 1.9.5 and 1.10.8. Also, it doesn't matter that the captor is for a Date. The same issue occurs if the parameter is of another type, such as Integer.
Mockito-16$$Make org.mockito.asm.signature package optional in Import-Packages.$$None
Mockito-17$$Mockito 1.10.x timeout verification needs JUnit classes (VerifyError, NoClassDefFoundError).$$If JUnit is not on the classpath and mockito is version 1.10.x (as of now 1.10.1 up to 1.10.19) and the code is using the timeout verification which is not supposed to be related to JUnit, then the JVM may fail with a VerifyError or a NoClassDefFoundError.
Mockito-18$$Return empty value for Iterables.$$I expect an Iterable to be mocked by default with an empty Iterable. I understand from the initial issue this behavior would be introduced in Mockito 2, but beta-8 still returns null. Could we return null for Iterables ?
Mockito-19$$InjectMocks injects mock into wrong field.$$When using @InjectMocks on some Android TextViews, the mock is injected into the wrong field.  We have two fields, txtGateView & txtNextStep in a class, and our test mocks out txtNextStep, then tried to inject. This field is injected wrong. From our quick testing, the name txtNextView doesn't matter, that can be changed. But both txtGateView and txtGateLabel messed things up. If we mock out both fields, it works correctly.
Mockito-20$$Allow convenient spying on abstract classes.$$Mockito is easy to use when the test needs to provide canned values for a certain method. But it gets harder when a canned value isn't sufficient.
Mockito-21$$Allow convenient spying on abstract classes.$$Mockito is easy to use when the test needs to provide canned values for a certain method. But it gets harder when a canned value isn't sufficient.
Mockito-22$$Can not Return deep stubs from generic method that returns generic type.$$if I try to mock a generic method which a generic returntype, where the returntype is derived from the generic type of the method using deep stubs I get a ClassCastException when calling when on it. When you don't use deep stubs and a raw Supplier mock to pass around it works:
Mockito-23$$WrongTypeOfReturnValue when abstract class have two abstract method.$$This is strange behavior, because the method lol() should not be called, but when I delete one abstract method everything is good.
Mockito-24$$fix some rawtype warnings in tests.$$None
Mockito-25$$Null Pointer when invoking Whitebox.invokeMethod() with null one of the params null.$$None
Mockito-26$$use @InjectMocks for final fields.$$I'm trying to upgrade the mockito version that we're using (1.8.5) to a newer version but there is a problem with @InjectMocks which since 1.9.0 doesn't inject into final field anymore.
Mockito-27$$Exception when stubbing more than once with when...thenThrow$$If I create a mock and stub a method so it throws an exception and do that twice the first exception will be thrown upon invoking the second stub instruction.
Mockito-28$$nicer textual printing of typed parameters$$When matchers fail but yield the same toString(), Mockito prints extra type information. However, the type information is awkwardly printed for Strings. I've encountered this issue while working on removing hard dependency to hamcrest.
Mockito-29$$fixed a verify() call example in @Captor javadoc.$$None
Mockito-30$$Failing tests on Windows machine$$None
Mockito-31$$Failing tests on Windows machine$$None
Mockito-32$$Mockito can't create mock on public class that extends package-private class$$Even if it can't be implemented, I think that mockito should throw some normal exception at time of creation. In my variant on first creation it returns wrong-working mock (invokes real method instead of stubbed). On second creation throws exception that doesn't really connected with problem. Everything works fine if you mock package-private parent.
Mockito-33$$ArgumentCaptor.fromClass's return type should match a parameterized type$$ArgumentCaptor.fromClass's return type should match a parameterized type. I.e. the expression ArgumentCaptor.fromClass(Class<S>) should be of type ArgumentCaptor<U> where S is a subtype of U. It should type check.
Mockito-34$$Source files should not be put in binary JAR$$Source files (*.java) should not be put into binary mockito-core.jar. It stupefies Idea to show decompiled file even when source jar is available.
Mockito-35$$possible NPE exception when class cannot be mocked via PowerMockito$$In version 1.10.5, the catch block needs to guard against a null proxyInstance.
Mockito-36$$Make Mockito JUnit rule easier to use$$Mockito JUnit rule easier to use by avoiding the need to pass test instance. Make it compatible with JUnit 4.7+ instead of 4.9+.
Mockito-37$$Make Mockito JUnit rule easier to use$$Mockito JUnit rule easier to use by avoiding the need to pass test instance. Make it compatible with JUnit 4.7+ instead of 4.9+.
Mockito-38$$Generate change list separated by types using labels$$As discussed on the mailing list instead of one big list of "Improvements" the change list for the release is divided into change types based on labels. It is required to specify which labels should be considered separately. Some other labels can be excluded (like "question" or "refactoring"). There is also headerForOtherChanges method to override default "Other" header.
