Time-1$$Partial.with fails with NPE$$Fails with yearOfCentury, year and yearOfEra. Probably because weekyear has a null range duration type.
Time-2$$Partial.with fails with NPE$$Fails with yearOfCentury, year and yearOfEra. Probably because weekyear has a null range duration type.
Time-3$$addDays(0) changes value of MutableDateTime$$Upon DST transition from summer to winter time zone, adding the amount of zero days to a mutable date time object changes the value of the object. The methods addMonths and addYears show the same problem; addSeconds, addMinutes and addHours are ok.  I have tested with version 2.3. However, if I repeat the test with Joda 1.5.2, the invocation of addDays(0) does not change the date's value.
Time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):
Time-5$$none standard PeriodType without year throws exception$$I tried to get a Period only for months and weeks with following code:  This throws following exception:  Even removing the year component with .withYearsRemoved() throws the same exception:
Time-6$$Questionable behaviour of GJChronology when dates pass 1BC$$I expect the following test to pass:  However, I never provided "0" for the year myself. I thought it was the job of the framework to skip over non-existent year 0 for me to return 1 BC?
Time-7$$DateTimeFormat.parseInto sometimes miscalculates year (2.2)$$The following code (which can be added to org.joda.time.format.TestDateTimeFormatter) breaks, because the input mutable date time's millis appear to be mishandled and the year for the parse is changed to 1999.
Time-8$$DateTimeZone.forOffsetHoursMinutes cannot handle negative offset < 1 hour$$DateTimeZone.forOffsetHoursMinutes(h,m) cannot handle negative offset < 1 hour like -0:30 due to argument range checking. I used forOffsetMillis() instead.  This should probably be mentioned in the documentation or negative minutes be accepted.
Time-9$$Ensure there is a max/min valid offset$$DateTimeZone does not apply a max/min value for an offset. However the parse method is limited to 23:59. Make 23:59:59.999 the maximum.
Time-10$$Days#daysBetween throw exception for MonthDay with 29 February$$Is there a way to avoid this happening? I understand fiddling around with the leap year, you're bound to get issues.
Time-11$$NPE in DateTimeZoneBuilder$$When a DateTimeZone is build with duplicate-named 'recurring saving time' in a first thread, all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone.create(). When a second thread does the same, an NPE is generated in ZoneInfoCompiler.verbose().  The cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler ...will initialize cVerbose only for the first thread and not for the subsequent ones. The NPE is caused by the autoboxing in: . A better approach could be to remove the initialization and test for null:
Time-12$$Check Calendar.ERA in LocalDate.fromCalendarFields$$None
Time-13$$Negative millis display incorrectly in Period.toString$$The last line should produce "PT-0.100S" instead of "PT0.100S".
Time-14$$Unable to add days to a MonthDay set to the ISO leap date$$It's not possible to add days to a MonthDay set to the ISO leap date (February 29th). This is even more bizarre given the exact error message thrown.
Time-15$$possibly a bug in org.joda.time.field.FieldUtils.safeMultiply$$It seems to me that as currently written in joda-time-2.1.jar org.joda.time.field.FieldUtils.safeMultiply(long val1, int scalar) doesn't detect the overflow if the long val1 == Long.MIN_VALUE and the int scalar == -1.  The attached file demonstrates what I think is the bug and suggests a patch.  I looked at the Joda Time bugs list in SourceForge but couldn't see anything that looked relevant.
Time-16$$DateTimeFormatter.parseInto broken when no year in format$$In Joda Time 2.0, the default year was set to 2000 so that Feb 29 could be parsed correctly. However, parseInto now overwrites the given instant's year with 2000 (or whatever iDefaultYear is set to). The correct behavior would seem to be to use the given instant's year instead of iDefaultYear. This does mean that Feb 29 might not be parseable if the instant's year is not a leap year, but in this case the caller asked for that in a sense.
Time-17$$Bug on withLaterOffsetAtOverlap method$$On the last two brackets we can see that withLaterOffsetAtOverlap is not undoing withEarlierOffsetAtOverlap as it should ( and not even working at all ).
Time-18$$GJChronology rejects valid Julian dates$$The 2nd statement fails with "org.joda.time.IllegalFieldValueException: Value 29 for dayOfMonth must be in the range [1,28]".  Given that I left the cutover date at the default (October 15, 1582), isn't 1500/02/29 a valid date in the GJChronology?
Time-19$$Inconsistent interpretation of ambiguous time during DST$$The inconsistency appears for timezone Europe/London.  These three DateTime objects should all represent the same moment in time even if they are ambiguous. Now, it always returns the earlier instant (summer time) during an overlap.
Time-20$$Errors creating/parsing dates with specific time zones.$$The results are out of 572 time zones 130 fail and 30 throw exceptions.  The failures are the most interesting. When I query DateTimeZone to get its time zone ids I will get a time zone like America/Atka. When I take that id and create a date time with it its time zone id is America/Adak. It is like there are multiple list of time zones in Joda time and they are out of sync.
Time-22$$Duration.toPeriod with fixed time zones.$$I have a question concerning the conversion of a Duration to Period. I'm not sure if this is a bug, or if there is a different way to do this.  The basis of the problem, is that using Duration.toPeriod() uses the chronology of the default time zone to do the conversion. This can cause different results from a timezone with DST and one without. This can be reproduced easily with this test. In the joda code, Duration.toPeriod() uses a period constructor that takes the chronology, but null is passed in, so the chronology of the default time zone is used, which leads to this behavior.  The javadoc of toPeriod() states that only precise fields of hours, minutes, seconds, and millis will be converted. But for a fixed timezone, days and weeks are also precise, which is stated in the javadoc for toPeriod(Chronology chrono). In our app, we need consistent behavior regardless of the default time zone, which is to have all the extra hours put into the hours bucket. Since Duration is supposed to be a 'time zone independent' length of time, I don't think we should have to do any chronology manipulation to get this to work.
Time-23$$Incorrect mapping of the MET time zone$$This timezone is mapped to Asia/Tehran in DateTimeZone. It should be middle europena time.
Time-24$$Incorrect date parsed when week and month used together$$It should print 2011-01-03 but it is printing 2010-01-04.
Time-25$$DateTimeZone.getOffsetFromLocal error during DST transition$$This may be a failure of my understanding, but the comments in DateTimeZone.getOffsetFromLocal lead me to believe that if an ambiguous local time is given, the offset corresponding to the later of the two possible UTC instants will be returned - i.e. the greater offset.  This doesn't appear to tally with my experience. In fall 2009, America/Los_Angeles changed from -7 to -8 at 2am wall time on November 11. Thus 2am became 1am - so 1:30am is ambiguous. I would therefore expect that constructing a DateTime for November 11th, 1:30am would give an instant corresponding with the later value (i.e. 9:30am UTC).
Time-26$$.withHourOfDay() sets hour inconsistantly on DST transition.$$When the hour of day is set to the ambiguous hour on the daylight to standard time transition in a given time zone the result is inconsistent for different time zones. Shoul the hour be set to the daylight hour or the standard hour for all time zones? I can't find anything that documents this behavior.  My test code below returns different results for different time zones. The very last assertion fails on the Australia time zone cutover.
Time-27$$Different behaviour of PeriodFormatter$$When the hour of day is set to the ambiguous hour on the daylight to standard time transition in a given time zone the result is inconsistent for different time zones. Shoul the hour be set to the daylight hour or the standard hour for all time zones? I can't find anything that documents this behavior.  My test code below returns different results for different time zones. The very last assertion fails on the Australia time zone cutover.
